\documentclass{article}
\usepackage[cm]{fullpage} %very small margins (around 1.5cm)
\usepackage[utf8]{inputenc} %sets input encoding to UTF-8, needed for Polish, Japanese, etc.
\usepackage[T1]{fontenc} %needed for Polish characters
\usepackage{lmodern} %this font handles Polish characters properly

\PassOptionsToPackage{usenames,dvipsnames,svgnames}{xcolor}

\input{../../includes/titlepage}

\logoleft{../../graphics/logo_pw.jpg}
\logoleftscale{0.395}
\logoright{../../graphics/logo_mini.png}
\logorightscale{0.16}
\university{Warsaw University of Technology}
\faculty{Faculty of Mathematics and~Computer~Science}
\location{Warsaw}
\supervisor{dr Lucjan Stapp}
\title{$\Phi$nite}
\description{application for building finite-state machine that is equivalent to a given regular
expression \newline and for simulating machine's evaluation of a given word}
\author{Mateusz Bysiek}
\date{21 Mar 2013}

\input{../../includes/documentmetric}

\company{WUT}
\documentsubject{technical analysis}
\documenttopicslist{technical analysis of the problem, details of used algorithms, interface specification}

\documentsummary{Author of the document analyses the problem of designing an application for solving
a well defined language\mbox{-}theory related problem, doing it from the developer team leader
perspective, i.e. providing definitions of expected application environment, developer environment,
user interface requirements, and all relevant algorithms.}

\openingdate{16 Mar 2013}
\version{0.16}
\status{pre-alpha}
\filename{bysiekm-technical-analysis.pdf}

\input{../../includes/footer}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol} %use \begin{multicols}{#} for # columns
\usepackage{enumitem} %remove vertical space in itemize with: [noitemsep,nolistsep]
\usepackage{tikz}
%\usepackage{minted} %use \begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,framesep=2mm]{c++}
\usepackage{tabularx}
\usepackage{../../includes/pgf-umlcd}

\usetikzlibrary{arrows,positioning,automata}

\newcommand{\writehere}{\textbf{\textcolor{red}{Write here!}}}

\begin{document}

\input{firstpages}

\section*{Abstract}

This is a technical analysis of problem of creating an application for building finite-state machine
that is equivalent to a given regular expression and for simulating machine's evaluation of a given
word.
Author of the document analyses the problem of designing an application for solving a well defined
language\mbox{-}theory related problem, doing it from the developer team leader perspective, i.e.
providing definitions of expected application environment, developer environment, user interface
requirements, and all algorithms used to perform the regular expression and finite-state machine
related tasks.

\section{The runtime environment}

This section provides a set of requiremets with regard to the environment, in which the developed
program will be run.

\subsection*{Definition}

\begin{itemize}

  \item \textit{the application} is a synonym for \titletext, the term includes the runtime of
  \titletext{} with the user documentation, but not the source code and class documentation.

\end{itemize}

\subsection{Hardware requirements}

The computer on which the application is run must conform with the minimum requirements that are
defined for operating system and the components listed in further sections. The application itself
must require at most 1GB of hard drive space and 1GB of RAM to work. The actual implementation does
not have to use all the available space, but it must work within the boundaries.

\subsection{Operating system}

The application is expected to work on the following set of operating systems:

\begin{itemize}

  \item Microsoft Windows 7 Professional x86

  \item Microsoft Windows 7 Professional x64

  \item Microsoft Windows 7 Ultimate x86

  \item Microsoft Windows 7 Ultimate x64

\end{itemize}

\subsection{Additional software}

Other than the operating system, the application cannot be expected to work corretly unless all of the
following components are present in the operating system:

\begin{enumerate}

  \item .NET Framework 4.0 Full Profile

  \item PDF (Portable Document Format) file viewer

  \item PDF-LaTeX toolkit that is able to create PDF files from LaTeX source code automatically, using
  command-line.

\end{enumerate}

The application may seem to work correctly without some of these components being present, but it is
undefined what will happen.

The development team shall provide portable (in the sense that their installation and/or
configuration by the user will not be required in order for them to work) runtimes for the latter
two components. The first component has to be installed by the user.

\section{Development process constraints}

This section provides a set of requirements with regard to the environment, in which the application
and its documentation will be developed.

\subsection*{Definitions}

\begin{itemize}

  \item \textit{the project} is term used for all of the listed: the runtime of \titletext{} with
  all documentation, the source code and required external libraries.

  \item the development process will follow the waterfall model

\end{itemize}

\subsection{Developing the application}

\begin{itemize}

  \item Visual Studio 2012 Ultimate will be used

  \item C\# will be used to implement main algorithms of \titletext: for building finite-state
  machine that is equivalent to a given regular expression and for simulating machine's evaluation
  of a given word

  \item .NET Framework 4.0 features such as lambda expressions and Linq will be used to simplify the
  implementation proces and make the code more readable.

  \item WPF (Windows Presentation Framework) will be used to create the user interface, via use of
  C\# and XAML

\end{itemize}

\subsection{Source code documentation}

\begin{itemize}

  \item All namespaces introduced in the development process have to be documented. 

  \item All classes, interfaces and enumerated types have to be at least briefly described. 

  \item All public properties and UI event handlers also have to be documented.

  \item The source code documentation will follow the standard C\# documentation rules, because the
  Visual Studio has built-in support for creation of such documentation.

  \item Where the rules of C\# documentation are not enough, the doxygen documentation format can be
  used: ex. to group classes into modules, to document namespaces, etc.

  \item Doxygen will be used to process the source code to create a set of web pages (which use HTML
  and CSS) with the complete documentation.

\end{itemize}

% \section{Used technologies}
% 
% \subsection{The runtime}
% 
% \begin{itemize}
% 
%   \item 
% 
% \end{itemize}
% 
% \subsection{The development}
% 
% The list of technologies for the runtime applies also to this section. Moreover, there are some
% extra components used exclusively for the development.  
% 
% \begin{itemize}
% 
%   \item 
% 
% \end{itemize}

%\newpage

\section{Graphical user interface}
The application shall have all of its features accessible via a graphical user interface (GUI).

\subsection{Main idea}

\subsubsection{Main menu}
Main menu contains all general options that are required to be implemented, but are not connected
with a specific step of calculation. Contents of the menu must not change during application
operation, but its certain entries may be temporarily disabled during some phases of computation.

Main menu will contain, ex. exit option, %load option, 
example selection option.

\subsubsection{Main area}
Main area will contain frequently changing content, as it may have any of the following: a text
field for entering a regular expression, button to proceed to the next step of computation, button
to abort computation, button to display final result, a table with intermediate results, a final
result, etc. Content of main area depends on context, i.e. previous actions of the user and current
status of application.

\subsubsection{Status bar}
Status bar must contain one of three phrases at all times, unless there are equivalent indicators
implemented (mentioned in each point):
\begin{itemize}

  \item ``busy'' - if program computes the final or intermediate result. %, or is loading data.
  
  Equivalent of this is locking all elements of the GUI while the program is busy.

  \item ``awaiting user interaction'' - if program is not busy, but intends to be right after user
  gives some information that may help with further computation. The phrase may be changed to other
  with the same meaning. This status is intended only for computation phase, and only for those
  parts of computation phase that require user input.
  
  Equivalent of this status is displaying a new window. All information and input fields needed by
  the user to help the program must be in this new window. When it is closed, program resumes
  computation.
  
  Since the user feedback mechanism is optional (provided that it is of course substituted with
  working implementation), in certain implementation scenarios this status will never occur (or
  window will never be shown). If development team is able to prove that this feature would really
  never be used, this status indication does not have to be implemented.

  \item ``ready'' - in all other situations, for example: after start-up, %after loading the data,
  after completing the computation.
  
  Equivalent of this status is a situation in which both previous mechanisms are implemented using
  second variant. If it is so, this status can be omitted.

\end{itemize}

Status bar may also temporarily contain some optional content that may help the user in completing
the user interaction phase, provided that the main area is not a proper place for this content.

\subsubsection{GUI mockup}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.6\textwidth]{../../graphics/PhiniteGuiMockup.png}
  \caption{schema of the graphical user interface}
\end{figure}

\newpage

\subsection{Regular expression input screen}
This screen, apart from above mentioned elements, must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item the text box for regexp input,

  \item information (or link to information) about how to write the expression; this information
  must include list of special symbols and their meaning,

  \item button that will invoke step-by-step computation,

  \item button that will invoke immediate computation up to final solution.

\end{enumerate}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{../../graphics/Screen1.png}
  \caption{regular expression input screen}
\end{figure}

\newpage

\subsection{Validation results screen}
This screen, in its main area, must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item the original expression given by the user,

  \item the expression that is a result of parsing process,

  \item depiction of the parse tree.

\end{enumerate}

\vspace{10pt} \noindent
This screen may not be shown if user selects immediate computation option on the previous screen.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{../../graphics/Screen2.png}
  \caption{validation results screen}
\end{figure}

\newpage

\subsection{Machine creation screen}
This screen, in its main area, must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item graph that represents the currently constructed fragment of the machine,

  \item table that contains the list of labeled expressions,

  \item table that contains the list of transitions between labeled expressions,

  \item buttons that enable the user to control the computation, i.e. enable him/her to proceed to
  the next step, go to final result, or abort computation,

  \item button that enables the user to create \LaTeX{} source code and subsequently a PDF file,

  \item button that enables the user to go to word evaluation phase.

\end{enumerate}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{../../graphics/Screen3.png}
  \caption{example of initial contents of machine creation screen}
\end{figure}

\newpage

At the beginning, a screen is displayed where input word is shown, and two empty tables are
displayed: one for list of labeled states and another for discovered transitions. In each step,
entries in tables may be added if in a given step some new state is labeled or is derived.

Moreover, there is a place reserved (in a scroll box) to display a graph that represents those
two tables in their current state. This graph will follow coloring of the example in
business analysis.

Moreover, the states derived in the last step have changed their border colors to light blue. And,
the state labeled in latest step is highlighted by having its background changed to light blue.

All states that exist longer that since latest step follow the usual coloring scheme.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{../../graphics/Screen4.png}
  \caption{example of final contents of machine creation screen}
\end{figure}

\newpage

\subsection{Word input screen}
This screen, in its main area, must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item a text box for input word,

  \item information (or link to information) about all rules that apply to the entered word,

  \item buttons for step-by-step and immediate solution.

\end{enumerate}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{../../graphics/Screen5.png}
  \caption{word input screen}
\end{figure}

\subsection{Evaluation screen}
This screen, in its main area, must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item text block containing input word,

  \item text block containing processed part of input,

  \item text block containing remaining part of input,

  \item graph that depicts the machine,

  \item buttons to control the evaluation process: to proceed to next step, to go to final result,
  and to abort evaluation.

\end{enumerate}

\vspace{10pt} \noindent
The word evaluation algorithm will use the same rules for coloring and formatting of graph of the
machine as it was used for its construction. The difference is that the tables are not displayed,
and the input expression is substituted with the input word that is evaluated.

\newpage

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.85\textwidth]{../../graphics/Screen6.png}
  \caption{example of evaluation taking place}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.85\textwidth]{../../graphics/Screen7.png}
  \caption{example of completed evaluation}
\end{figure}

\newpage

\subsection{User-assisted machine creation screen}

Phinite will in certain scenarios (described later on) ask user about decision with regard to
finite-state machine construction process.

The screen dedicated for such situations must contain:
\begin{enumerate}[noitemsep,nolistsep]

  \item a table of currently labeled states that has at very least those columns that an analogous
  table in machine creation screen has,

  \item textual representation of currently evaluated regular expression,

  \item button that indicates that user decides that currently evaluated expression is different
  from any labeled so far,

  \item button that indicates that user decides that currently evaluated expression is equivalent to
  the one selected in the table,

  \item button that launches auto-resolver that makes automatic assessment of a state equivalence
  probability and acts upon it.

\end{enumerate}

\subsection{Other screens}

The application may contain other screens, which will be defined by the developing team. For
example, there may be a special screen for user-assisted machine creation, as well as a screen that
allows the user to edit \LaTeX{} source code before the PDF is created. Those screens must be
arranged in the same theme that other screens, but its content is not subject to the requirements.
Also, no extra screen can be a part of a workflow defined in this document - such screen can only be
part of a branch that goes outside the workflow and returns back to the same place.

\section{Workflow}

The basic application workflow is defined below:

\vspace{10pt}
Regular expression input phase (regular expression input screen, validation results screen),

$ \downarrow $

Machine construction phase (machine creation screen, user-assisted machine creation screen),

$ \downarrow $

Evaluation phase (word input screen, evaluation screen),

$ \downarrow $

Regular expression input phase.

\newpage

\section{Classes}
This section goes through the most important classes used in the project.

\subsection{Regular expression}
Numerous classes are required to store regular expression from its raw form up to completely parsed
form.

\begin{enumerate}

  \item First of all, \verb|PartialExpressionRole|, enumeration of roles that a given part of the
  expression can assume.

  \item \verb|UnaryOperator|, enumeration of unary operators that a given part of the expression can
  be affected by.

  \item \verb|PartialExpression|, a single node of a parse tree that stores the actual
  expression as a generative grammar.

  \item Enumeration of tags used to tag the input character sequence named \verb|InputSymbolTag|.

  \item Finally, \verb|RegularExpression|, an object that stores all the data about the regular expression.

\end{enumerate}

% \begin{minted}[mathescape,linenos,numbersep=5pt,gobble=1,tabsize=3,framesep=2mm]{csharp}
% 	public class RegularExpression
% 	{
% 		public static readonly KeyValuePair<string, InputSymbolTag>[] ReservedSymbols;
% 
% 		public static readonly Dictionary<InputSymbolTag, string> TagsStrings;
% 	}
% \end{minted}

% \begin{minted}[mathescape,linenos,numbersep=5pt,gobble=1,tabsize=3,framesep=2mm]{csharp}
% 	public enum PartialExpressionRole
% 	{
% 		EmptyWord, Letter, Concatenation, Union, Undetermined
% 	}
% \end{minted}

\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}

    \begin{class}[text width=8cm]{PartialExpression}{0,0}
      %\attribute{+ Role : PartialExpressionRole}
      \attribute{+ Root : PartialExpression}
      \attribute{+ Parts : ReadOnlyCollection<PartialExpression>}
      \attribute{+ Value : string}
      %\attribute{+ Operator : UnaryOperator}
  
      \operation{+ Optimize() : void}
      \operation{+ Derive(removedLetter : string) : void}
      \operation{+ GeneratesEmptyWord() : bool}
    \end{class}

    \begin{enumeration}[text width=4cm]{PartialExpressionRole}{10,2}
      \attribute{EmptyWord}
      \attribute{Letter}
      \attribute{Concatenation}
      \attribute{Union}
      \attribute{Undetermined}
    \end{enumeration}

    \begin{enumeration}[text width=3cm]{UnaryOperator}{12,-2}
      \attribute{None}
      \attribute{KleeneStar}
      \attribute{KleenePlus}
    \end{enumeration}

    \aggregation{PartialExpressionRole}{+ Role}{1}{PartialExpression}

    \aggregation{UnaryOperator}{+ UnaryOperator}{1}{PartialExpression}

    \begin{class}[text width=11cm]{RegularExpression}{2,-7}
      \attribute{- taggedInput : List<KeyValuePair<string, InputSymbolTag> >}
      \attribute{- tagCount : Dictionary<InputSymbolTag, uint>}
      \attribute{+ Alphabet : ReadOnlyCollection<string>}
      \attribute{+ Input : string}

      \operation{+ EvaluateInput() : void}
      \operation{- TagInput() : void}
      \operation{- CountTags() : void}
      \operation{- ParseInput() : void}
      \operation{+ Optimize() : void}
      \operation{+ Derive(removedLetter : string) : RegularExpression}
      \operation{+ GeneratesEmptyWord() : bool}
    \end{class}

    \composition{PartialExpression}{- parsedInput}{1}{RegularExpression}

    \begin{enumeration}[text width=4cm]{InputSymbolTag}{11,-5}
      \attribute{Letter}
      \attribute{Union}
      \attribute{KleeneStar}
      \attribute{KleenePlus}
      \attribute{OpeningParenthesis}
      \attribute{ClosingParenthesis}
      \attribute{EmptyWord}
    \end{enumeration}

    \aggregation{InputSymbolTag}{}{1..*}{RegularExpression}

  \end{tikzpicture}
  \caption{diagram of classes related to regular expression parsing}
\end{figure}

\newpage

\subsection{Finite-state machine}
Few classes are required to store information about the constructed finite-state machine, because
most of the computational complexity is on the side of \verb|PartialExpression| class.

\begin{enumerate}

  \item \verb|MachineTransition|, that stores information about a single transition from a certain
  state to another.

  \item Finally, \verb|FiniteStateMachine|, a place to store all information about a single
  finite-state machine.

\end{enumerate}

\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}

    \begin{class}[text width=13cm]{FiniteStateMachine}{0,0}
      \attribute{+ Input : RegularExpression}
      \attribute{+ InitialState : RegularExpression}
      \attribute{- notLabeled : List<RegularExpression>}
      \attribute{- notDerivedIds : List<int>}
      \attribute{- equivalentStatesGroups : List<KeyValuePair<int, List<RegularExpression> > >}
      \attribute{- notOptimizedTransitions : List<Tuple<int, string, RegularExpression> >}
      \attribute{+ States : ReadOnlyCollection<RegularExpression>}
      \attribute{+ AcceptingStates : ReadOnlyCollection<RegularExpression>}

      \operation{+ Construct(numberOfSteps : int) : void}
      \operation{- InitializeEvaluation() : void}
      \operation{+ LabelNextExpression() : bool}
      \operation{+ DeriveNextExpression() : bool}
      \operation{+ IsConstructionFinished() : bool}
    \end{class}
    
    \begin{class}[text width=4cm]{Tuple}{-1,6}
      \attribute{+ Item1 : int}
      \attribute{+ Item2 : List<string>}
      \attribute{+ Item3 : int}
    \end{class}

    \begin{class}[text width=5cm]{MachineTransition}{7,6}
      \inherit{Tuple}
 
      \operation{+ AddLetter(letter : string) : void}
      \operation{+ AddAllLetters(letters : IEnumerable<string>) : void}
    \end{class}

    \composition{MachineTransition}{+ Transitions}{0..*}{FiniteStateMachine}
    %\unidirectionalAssociation{RegularExpression}{Input}{1}{FiniteStateMachine}

  \end{tikzpicture}
  \caption{diagram of classes needed for finite-state machine related tasks}
\end{figure}

The development team must preserve the types and names of all public properties of all types
mentioned in the two above sections. The names and return types of public methods also have to be
preserved. The names of all listed classes and enumerations also have to be exactly as specified.
All public properties must be treated as read-only - some backing fields should be created and used
for processing.

Other names and types can be changed, added or removed at will, provided that this is a properly
justified decision, and all of the names still carry a meaning corresponding to their true role. The
development team may also add some other classes that are used internally during the processing. One
exception: the \verb|parsedInput| field cannot be removed or changed.

\newpage

\section{Algorithms}

\subsection{Conversion of plain text into a RegularExpression object}
The algorithm should follow the standard procedure applied in the are of natural language
processing. Of course in case of this algorithm that process is simplified greatly because of the
fact that we do not parse a human language but a machine language.

\subsubsection{Tagging}
First step is to tag the input data accordingly. This is done for several reasons:

\begin{enumerate}

  \item As the tagging is done, algorithm eliminates ignored symbols by not adding them to the
  tagged input.

  \item The tagging eliminates the difference between letters, all non-special symbols are simply
  regarded as ``letters''. From the point of view of further parsing, this greatly simplifies the
  process.

  \item As the input is tagged, it becomes much easier to detect which parts of it belong together.

  \item The validation and therefore stopping in case of some mistakes like open bracket without a
  corresponding closing one, or placing a unary operator after an opening bracket, etc. is
  simplified.

\end{enumerate}

Program shall go through all the letters and assign a tag to each of them. The direction of the
processing (left to right or right to left) does not matter. In fact, the solution can, but does not
have to be, parallelized. In case of sequential solution the worst case running time must be $O(n)$,
in case of parallel solution $O(n/k)$ assuming $k$ is the number of cores used, $k \leq n$.

The developer should pay attention to the fact that some special symbols consist of several
characters. In such cases a single tag is placed over all of the characters that constitute such
symbol. Therefore the parallelization may add some complications.

Results of tagging are stored in \verb|taggedInput| field. Relevant tag counts in the
\verb|tagCount| field are incremented on-the-go.

\subsubsection{Tag counting}
In this step the algorithm simply checks (using already prepared \verb|tagCount| field) the counts
of parentheses to ensure that there is the same number of opening and closing ones.

\subsubsection{Parsing}
Third step is to parse the tagged input into a tree. A tree created by parsing a plain text using a
certain grammar is called a parse tree in research texts related to natural language processing.

The steps of the algorithm and definitions used later on:
\begin{enumerate}

  \item a new, empty \verb|PartialExpression| is created and it becomes a current part

  \item current part is always labeled as ``Part''

  \item Part becomes a root part of the currently created parse tree

  \item root of the current parse tree is always labeled as ``Root''

  \item the role of Part is set to \verb|Undetermined|

  \item role of the current part is always labeled as ``Role''

  \item the algorithm goes through all characters of the input, starting from the first

  \item at each step, the currently evaluated symbol is labeled as ``Symbol''

  \item at each step, the actions of the algorithm depend on the Role, Symbol and Root; these
  actions are described in a separate table that follows

  \item if there are no more symbols to parse, the part that is Root is set as a root of the parse
  tree of the whole regular expression (field \verb|parsedInput| of \verb|RegularExpression|)

\end{enumerate}

The procedure is a recursive one. Parentheses are the triggers for recursion. The below table shows
the behaviour of the algorithm. This table is a human-readable version of an underlying grammar that
is used to create the parse tree.

\vspace{10pt} \noindent
\begin{tabularx}{\textwidth}{l|l|l|X}

Role & Symbol & Root & result \\ \hline

\verb|Undetermined| & \verb|EmptyWord| & $*$ &

1) Role is set to \verb|Concatenation| \newline
2) a new part with role \verb|EmptyWord| is added to parts of Part \\

\verb|Undetermined| & \verb|Letter| & $*$ &

1) Role is set to \verb|Concatenation| \newline
2) and a new part with role \verb|Letter| and value of the Symbol is added to parts of Part \\

\verb|Concatenation| & \verb|EmptyWord| & $*$ &

a new part with role \verb|EmptyWord| is added \\

\verb|Concatenation| & \verb|Letter| & $*$ &

a new part with role \verb|Letter| and value of the Symbol is added \\

\verb|Concatenation| & \verb|Union| & $\equiv$Part &

1) a new part with role \verb|Union| is created, and this new part is set as Root; \newline
2) Part is added to the list of parts of Root (becoming the first part in this list) \newline
3) a new part with \verb|Undetermined| role is created, it is appended to the parts of the Root and
it is set as Part \\

\verb|Concatenation| & \verb|Union| & $\not\equiv$Part &

%1) a new part with role \verb|Union| is created, and this new part is set as Root; \newline
%1) Part is added to the parts of Root \newline
a new part with \verb|Undetermined| role is created, it is appended to the parts of the Root and
it is set as Part \\

\verb|Concatenation| & \verb|OpeningParenthesis| & $*$ &

1) the sub-procedure of parsing starts from step one (see algorithm), and the sub-procedure treats the first
symbol after the parenthesis as the first symbol of input \newline
2) when the sub-procedure ends, the returned partial expression is appended to the list of parts of Part \newline
3) the procedure skips all symbols parsed by the sub-procedure and continues \\

\verb|Concatenation| & \verb|ClosingParenthesis| & $*$ &

the parsing sub-procedure ends, Root is returned \\

\verb|Concatenation| & \verb|KleeneStar| & $*$ &

the operator of the last of the parts of Part is set to \verb|KleeneStar| \\

\verb|Concatenation| & \verb|KleenePlus| & $*$ &

the operator of the last of the parts of Part is set to \verb|KleenePlus| \\

\end{tabularx}

\vspace{10pt} All other encountered pairs of Role-Symbol result in an undefined behaviour. Such pairs would
however violate the rules of the underlying grammar, therefore they can, and shall be detected in
the tagging step. Also, in the table there are some assumptions about data integrity which are
omitted. Catching of invalid tag sequences in before starting parsing phase and correct
implementation of the above algorithm ensures data integrity i.e. ensures that the correct parse
tree will be built.

\subsubsection{Optimization}
The fourth and the last phase is to optimize the parse tree i.e. eliminate any redundant productions
and useless symbols. This step is optional, but highly recommended.

Parse tree has redundant productions if its underlying grammar can generate the same word using more
than one set of productions. Eliminating the redundant productions means that the grammar still
generates the same language, but fewer (or no) productions are redundant.

Below is the list of patterns that are considered not optimal, together with methods of optimization:
\begin{enumerate}

  \item A part that has role of \verb|Concatenation| or \verb|Union|, and has only one part - it
  shall be converted to the part itself.

  In this case special rules regarding operators apply:

  \noindent
  \begin{tabular}{c|c|c}
  Operator of parent & Operator of its single part & resulting operator \\ \hline
  \verb|None| & $*$ & $*$ \\
  $*$ & \verb|None| & $*$ \\
  \verb|KleeneStar| & $*$ & \verb|KleeneStar| \\
  $*$ & \verb|KleeneStar| & \verb|KleeneStar| \\
  \verb|KleenePlus| & \verb|KleenePlus| & \verb|KleenePlus| \\
  \end{tabular}

  \vspace{10pt} The algorithm shall analyze if the rules apply to the current situation from top to
  bottom, and apply the first matching rule.

  \item A part that is a part of \verb|Concatenation| and its role is equal to \verb|EmptyWord| -
  such part can be deleted altogether unless it is the only part of that \verb|Concatenation|.

  \item If a \verb|Union| has some parts that are equal, the duplicates can be safely deleted.

  \item If we have two consecutive parts of a \verb|Concatenation| that satisfy all of the following conditions:

  \begin{itemize}

    \item both have unary operators

    \item those unary operators may be different or the same

    \item without taking operators into account, these parts are equal

  \end{itemize}

  then, one of the parts can be safely removed provided that the operator of the other part is
  modified accordingly:

  \noindent
  \begin{tabular}{c|c|c}
  initial operator & operator & resulting operator \\
  of the remaining part & of removed part & of the remaining part \\ \hline
  \verb|KleeneStar| & \verb|KleeneStar| & \verb|KleeneStar| \\
  \verb|KleeneStar| & \verb|KleenePlus| & \verb|KleenePlus| \\
  \verb|KleenePlus| & \verb|KleenePlus| & \verb|KleenePlus| \\
  \verb|KleenePlus| & \verb|KleeneStar| & \verb|KleenePlus| \\
  \end{tabular}
  
  %\vspace{10pt}
  %and cases where operators are identical are covered by point 2. of this list.

  \item If we have a pair of parts of a \verb|Union|, which are placed anywhere in the union, that
  satisfy all of the following conditions:

  \begin{itemize}

    \item either both of them have any (but different) unary operator, or one of them has
    \verb|KleenePlus| and the other has no operator

    \item without taking operators into account, these parts are equal

  \end{itemize}

  then, one of the parts can be safely removed provided that the operator of the other part is
  modified accordingly:

  \noindent
  \begin{tabular}{c|c|c}
  initial operator & operator & resulting operator \\
  of the remaining part & of removed part & of the remaining part \\ \hline
  \verb|KleenePlus| & \verb|None| & \verb|KleenePlus| \\
  \verb|None| & \verb|KleenePlus| & \verb|KleenePlus| \\
  \verb|KleeneStar| & \verb|KleenePlus| & \verb|KleeneStar| \\
  \verb|KleenePlus| & \verb|KleeneStar| & \verb|KleeneStar| \\
  \end{tabular}
  
  \vspace{10pt}
  and cases where operators are identical are covered by point 3. of this list.

  \item If some part $x$ is a is a \verb|Concatenation|, it has no operator, and it is a part of
  another \verb|Concatenation| $y$, which also has no operator, then all parts of $x$ can be moved
  into $y$.

  For example: $y = ay$, $x = bc$, then, instead of having $y = a(bc)$, we can safely have $y = abc$

  \item If some part $x$ is a is a \verb|Union|, it has no operator, and it is a part of another
  \verb|Union| $y$, which also has no operator, then all parts of $x$ can be moved into $y$.

  For example: $y = a+y$, $x = b+c$, then, instead of having $y = a+(b+c)$, we can safely have $y =
  a+b+c$

  \item If some partial expression is a \verb|Union| and has \verb|KleeneStar|, then every its part
  that is a \verb|EmptyWord| can be safely deleted, because the empty word will be generated
  anyway.

  For instance: $(a+\epsilon+b)^* \equiv (a+b)^*$

\end{enumerate}

This step is needed to ensure that the implementation second algorithm can be greatly simplified.
The implementation of the second algorithm becomes much more difficult without assumption that the
parse tree is optimal.

It is still possible to implement the derivation and labeling algorithm without optimizations, that
is why the implementation of optimization is not mandatory.

\newpage

\subsection{Conversion of RegularExpression object into FiniteStateMachine object}

\subsubsection{Step-by-step construction}

The two following (labeling and derivation) steps are executed in the loop, until the computation is
complete. Conditions for ending the computation are described in relevant section later on.

Splitting the computation into loop consisting of small, repetitive steps, is necessary for
implementation of step-by-step computation. When immediate result is needed, a loop can be simply
set to run without interruption.

\subsubsection*{Labeling step}

\begin{enumerate}

  \item The first element from \verb|notLabeled| list is taken, it becomes the current element:
  ``Element''.

  \item If \verb|equivalentStatesGroups| is empty:

  \begin{itemize}
    \item the Element is added to that list with $key = 0$
  \end{itemize}

  else:

  \begin{enumerate}

    \item The \verb|equivalentStatesGroups| list is checked whether it contains Element. If it does,
    the algorithm goes to point 3.

    \item if it does not, then the algorithm breaks and the user is prompted to provide his opinion
    regarding the Element, i.e. if in user's opinion some state from \verb|States| is equivalent to
    the Element.

    \item When the user answers false, the algorithm continues and adds new entry to
    \verb|equivalentStatesGroups|, with new $key = $\verb|equivalentStatesGroups.Count| and goes to point 3.

    \item When the users indicates to what already labeled state the Element is equivalent, the
    algorithms adds a new state to the list of states with $key$ equal to the user indicated state
    number - in the field \verb|equivalentStatesGroups|.

  \end{enumerate}

  \item Algorithm iterates through \verb|notOptimizedTransitions| and for each its entry that has
  the resulting state equal to Element.

  \begin{enumerate}

    \item Adds a new \verb|MachineTransition| to \verb|Transitions| with the corresponding ids and
    letter(s).

    \item Removes the entry from \verb|notOptimizedTransitions|.

  \end{enumerate}

  \item The Element is removed from \verb|notLabeled| list.

\end{enumerate}

\subsubsection*{Derivation step}

\begin{enumerate}

  \item The first element from \verb|notDerivedIds| list is taken, then its corresponding element from
  \verb|equivalentStatesGroups| is taken and it becomes the derived element: ``Element''.

  \item The Element is derived for each letter that exist in its alphabet. The derivation procedure
  is as follows:
  
  \begin{enumerate}

    \item A copy of parse tree of Element is made, this copy becomes the currently processed tree.

    \item Currently processed tree is always labeled ``Tree''.

    \item The Tree is processed using the rules contained in the tables that follow. In that tables:
    Role is simply the role of Tree, Operator is the Tree's unary operator.
    
    \item At first the transformations from the first table are applied, then those from the second.

    \item A new \verb|RegularExpression| object is created from a transformed Tree, and it
    becomes the derived element.

  \end{enumerate}

  \item for each derived element:

  \begin{itemize}

    \item if derivation is not null (that is equivalent to entering the rejecting state), a new
    entry is added to a list of not optimized transactions: \verb|notOptimizedTransitions|, and that
    entry has: a) the id from \verb|notDerivedIds| corresponding to Element (exactly the same as in
    step 1.), b) the letter by which the derivation was made, and of course c) the result of
    derivation

  \end{itemize}

  \item the id of Element is removed from \verb|notDerivedIds|

\end{enumerate}

The first table with transformations:

\vspace{10pt}
\noindent
\begin{tabularx}{\textwidth}{l|X}

Operator & actions \\ \hline

\verb|None| & none \\ \hline

\verb|KleeneStar| &

1) new part with copy of Tree is created, but copy's operator is set to \verb|None|; \newline
2) new part with copy of Tree is created; \newline
3) a \verb|Concatenation| of parts from 1) and 2) is created; \newline
4) new part that is an \verb|EmptyWord| is created; \newline
5) Role is set to \verb|Union|; \newline
6) Operator is set to \verb|None|; \newline
7) All Tree parts are removed; \newline
8) part from 4) is added to Tree parts; \newline
9) part from 3) is appended to Tree parts \\ \hline

\verb|KleenePlus| &

1) new part with copy of Tree is created, but copy's operator is set to \verb|None|; \newline
2) new part with copy of Tree is created, but copy's operator is set to \verb|KleeneStar|; \newline
%3) a \verb|Concatenation| of parts from 1) and 2) is created; \newline
%4) new part that is an \verb|EmptyWord| is created; \newline
3) Role is set to \verb|Concatenation|; \newline
4) Operator is set to \verb|None|; \newline
5) All Tree parts are removed; \newline
6) part from 1) is added to Tree parts; \newline
7) part from 2) is appended to Tree parts \\

\end{tabularx}

%\newpage

\vspace{10pt}
The second table with transformations:

\vspace{10pt}
\noindent
\begin{tabularx}{\textwidth}{l|X}

Role & actions \\ \hline

\verb|EmptyWord| &

Role is set to \verb|Invalid| \\ \hline

\verb|Letter| &

if value equals to that of derived letter, Role is set to \verb|EmptyWord|, otherwise Role is set to
\verb|Invalid| \\ \hline

\verb|Concatenation| &

\textbf{if} 1st part has a \verb|KleeneStar| operator:

1) new partial expression is created as a copy of this 1st part, but operator of the copy is set to
\verb|None|;

2) new partial expression is created as a copy of Tree, and 1st part of this copy is removed;

3) yet another partial expression is created as a copy of Tree, and 1st part of this copy is set to
expression created in 1);

4) Role is set to \verb|Union|; \newline
5) All Tree parts are removed; \newline
6) part from 2) is added to Tree parts; \newline
7) part from 3) is appended to Tree parts

\vspace{5pt}
\textbf{else if} 1st part is a union that has empty word:

1) new partial expression is created as a copy of this 1st part; \newline
2) all parts of this copy that are empty words are removed;
%, but operator of the copy is set to
%\verb|None|;

3) another partial expression is created as a copy of Tree, and 1st part of this copy is set to
expression created in 1-2);

4) new partial expression is created as a copy of Tree, and 1st part of this copy is removed;

5) Role is set to \verb|Union|; \newline
6) All Tree parts are removed; \newline
7) part from 3) is added to Tree parts; \newline
8) part from 4) is appended to Tree parts

\vspace{5pt}
\textbf{else}:

for the first part of Tree, launch the derivation sub-procedure where only steps from 2.(b) to 2.(d)
are executed \\ \hline

\verb|Union| &

for each part in Tree parts, launch a derivation sub-procedure where only steps from 2.(b) to 2.(d)
are executed \\

\end{tabularx}

\newpage

\subsubsection{Ending the computation}

Computation is regarded as complete when after the derivation step, both \verb|notLabeled| and
\verb|notDerived| lists are empty.

\subsubsection*{LaTeX output}

There will be a feature that consists of constructing a latex source and pdf file from that source.
The latex code is created if user selects a relevant option. This option is made available only
after the machine is fully constructed. The latex file will contain two tables: with labeled states
and with transitions. It will also contain a code that, after processing by pdf-latex software, will
generate a simple graph that depicts the machine. This graph must follow standard
formatting and coloring used in mathematics to draw finite-state machine. The representation may
differ from the one presented in the graphical user interface.

After the pdf file is generated, it should be automatically displayed to the user. If there are any
errors in the processing or creating the latex code, or displaying the made pdf file, the user must
be notified via a message box.

%\newpage

\subsection{Evaluation of a given word using FiniteStateMachine object}

As the input, the algorithm takes fully constructed finite-state machine, and a word. Algorithm goes
through the word from beginning to the end, letter by letter.

Remark 1:

User can use any characters to form the word, but if he/she uses some symbols that are used as
special symbols in the process of constructing the machine, such as parentheses, the word will be
always rejected, because no machine constructed by the application has transition over letter
\verb|(| or\verb|)|.

Remark 2:

The machine does not change in current algorithm - only the highlighted state changes.

\subsubsection{Procedure}

\begin{enumerate}

  \item All characters of input are marked as not processed.

  \item Current state of machine is set to its \verb|InitialState|. Current state is always
  highlighted by either interchanging background color with text color, or by changing background to
  light blue. Only one highlight scheme must be chosen, and has to remain the same at all steps.

  \item A loop starts.

  \item If there are no not processed letters, go to one step before the last. 

  \item If there are, check if there is a transition from current state to some state, over the
  currently processed letter of input. If there is, change current state and mark the letter as
  processed. If there is no such transition, highlight current state in orange and go to the last step.

  \item Loop ends, go back to step 3.

  \item If current state is on the list of \verb|AcceptingStates|, the current state is highlighted
  in green. Otherwise, it is highlighted in orange.

  \item Algorithm ends. 

\end{enumerate}

\end{document}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Phinite
{
	/// <summary>
	/// Used to generate LaTeX code used as a accepting output of the application.
	/// </summary>
	public static class LatexWriter
	{
		public static readonly string LatexOutputTextOpening
			= "\\documentclass{article}\n"
			+ "\n"
			+ "\\usepackage{fullpage}\n"
			+ "\\usepackage{tabularx}\n"
			+ "\\usepackage{breqn}\n"
			//+ "\\usepackage{amsmath}\n"
			+ "\\usepackage[usenames,dvipsnames,svgnames]{xcolor}\n"
			+ "\\usepackage{tikz}\n"
			+ "\\usetikzlibrary{arrows,positioning,automata}\n"
			+ "\\usepackage{textcomp}\n"
			+ "\n"
			+ "\\begin{document}\n"
			+ "\n"
			+ "\\title{Finite-state machine constructed from a regual expression}\n"
			+ "\\author{Generated by $\\Phi$NITE}\n"
			+ "\\date{\\today}\n"
			+ "\\maketitle";

		public static readonly string LatexOutputTextClosing
			= @"\end{document}";

		public static string GenerateFullLatex(string originalInput,
			RegularExpression regexp, FiniteStateMachine fsm,
			bool includeOpening, bool includeEnding)
		{
			StringBuilder s = new StringBuilder();

			if (includeOpening)
			{
				s.AppendLine(LatexOutputTextOpening);
				s.AppendLine();
			}

			s.AppendLine(@"\section{Summary}");
			s.AppendLine(@"This document illustrates process of construction of a finite-state machine that");
			s.AppendLine(@"is equivalent to a given regular expression.");
			s.AppendLine(@"This document and its \LaTeX{} source code are \textcopyleft{} copyleft - you are free");
			s.AppendLine(@"to use them in any way.");
			s.AppendLine();

			s.AppendLine(@"\section{Input}");
			s.AppendLine("Input expression:");
			s.AppendLine(@"\begin{dmath*}");
			s.AppendLine(originalInput.Replace(RegularExpression.TagsStrings[InputSymbolTag.EmptyWord], @"\epsilon"));
			s.AppendLine(@"\end{dmath*}");
			s.AppendLine();

			s.AppendLine(@"\noindent");
			s.AppendLine(@"Input expression after optimizations and with ambiguity safeguards:");
			s.AppendLine(@"\begin{dmath*}");
			s.AppendLine(regexp.ToString().Replace(RegularExpression.TagsStrings[InputSymbolTag.EmptyWord], @"\epsilon"));
			s.AppendLine(@"\end{dmath*}");
			s.AppendLine();

			s.AppendLine(@"\noindent");
			s.AppendLine(@"Further calculations are based on the preprocessed (i.e. second) expression.");
			s.AppendLine();

			//s.AppendLine(@"\section{Solution process}");
			//s.AppendLine(@"Not implemented.");
			//s.AppendLine();
			//\subsection{Labeling}
			//\subsection{Derivation}

			//s.AppendLine(@"\newpage");
			s.AppendLine();

			s.AppendLine(@"\section{Final result}");
			s.AppendLine(@"This section contains both textual and graphical representations of the solution.");
			s.AppendLine();

			s.AppendLine(@"\subsection{States}");
			s.AppendLine(@"The table lists all distincts states that were identified, together with labels that were assigned to them.");
			s.AppendLine();

			s.AppendLine(@"\vspace{10pt}");
			s.AppendLine(StatesTable(fsm));
			s.AppendLine();

			s.AppendLine(@"\subsection{Transitions}");
			s.AppendLine(@"The table lists all transitions that do not lead to rejecting state.");
			s.AppendLine();

			s.AppendLine(@"\vspace{10pt}");
			s.AppendLine(TransitionsTable(fsm));
			s.AppendLine();

			s.AppendLine(@"\subsection{Graph}");
			s.AppendLine(@"The figure below shows a deterministic finite-state machine that is equivalent to the given input.");
			s.AppendLine(@"For simplification, the rejecting state is not drawn. If for any state for any letter of the alphabet,");
			s.AppendLine(@"there is an edge missing, it means that such transition leads to rejecting state.");
			s.AppendLine();

			s.AppendLine(DrawGraph(fsm));
			s.AppendLine();

			if (includeEnding)
			{
				s.AppendLine(LatexOutputTextClosing);
				s.AppendLine();
			}

			return s.ToString();
		}

		private static string StatesTable(FiniteStateMachine fsm)
		{
			StringBuilder s = new StringBuilder();

			s.AppendLine(@"\noindent");
			s.AppendLine(@"\begin{tabularx}{\linewidth}{Xcl}");
			s.AppendLine(@"\hline");
			s.AppendLine(@"Expression & State & Remarks \\");
			var states = fsm.States;
			var accepting = fsm.AcceptingStates;
			var initial = fsm.InitialState;
			int i = 0;
			foreach (var state in states)
			{
				s.AppendLine(@"\hline");
				s.Append(@"$").Append(state).Append(@"$ & $").Append(@"q_{").Append(i++).Append(@"}$ &");
				if (state == initial)
					s.Append(" initial state");
				if (accepting.Any(x => x == state))
				{
					if (state == initial)
						s.Append(",");
					s.Append(" accepting state");
				}
				s.AppendLine(@" \\");
			}
			s.AppendLine(@"\hline");
			s.AppendLine(@"\end{tabularx}");

			return s.ToString();
		}

		private static string TransitionsTable(FiniteStateMachine fsm)
		{
			StringBuilder s = new StringBuilder();

			s.AppendLine(@"\noindent");
			s.AppendLine(@"\begin{tabularx}{\linewidth}{XcccX}");
			s.AppendLine(@"\hline");
			s.AppendLine(@"Starting expression & From & Symbol & To & Resulting expression \\");
			var states = fsm.States;
			foreach (var transition in fsm.Transitions)
			{
				s.AppendLine(@"\hline");
				s.AppendLine(@"$");
				s.Append(states[transition.Item1]).Append(@"$ & $q_{").Append(transition.Item1);
				s.Append(@"}$ & $");
				s.Append(String.Join(@", \; ", transition.Item2));
				s.Append(@"$ & $q_{");
				s.Append(transition.Item3).Append(@"}$ & $").Append(states[transition.Item3]);
				s.Append(@"$ \\");
			}
			s.AppendLine(@"\hline");
			s.AppendLine(@"\end{tabularx}");

			return s.ToString();
		}

		private static string DrawGraph(FiniteStateMachine fsm)
		{
			StringBuilder s = new StringBuilder();

			s.AppendLine(@"\begin{figure}[ht!]");
			s.AppendLine(@"  \centering");
			s.AppendLine(@"  \begin{tikzpicture}");
			//s.AppendLine(@"    [>=stealth',shorten >=1pt,node distance=2cm,on grid,initial/.style={}]");
			//s.AppendLine(@"    [->,>=stealth',shorten >=1pt,node distance=2cm,auto,transform shape]");
			s.AppendLine(@"    [->,>=stealth',shorten >=1pt,node distance=2.5cm,on grid,auto,transform shape]");
			s.AppendLine();

			//s.AppendLine(@"    \node[initial,state] (q0) {$q_0$};");
			var states = fsm.States;
			for (int i = 0; i < states.Count; ++i)
			{
				var state = fsm.States[i];
				s.Append(@"    \node[");
				if (i == 0)
					s.Append(@"initial,");
				s.Append(@"state");
				if (fsm.AcceptingStates.Contains(state))
					s.Append(@",accepting");
				s.Append(@"] (q").Append(i).Append(@")");
				if (i > 0)
				{
					s.Append(@" [below right = ");
					//if(false) // TODO: decrease distance between nodes if it is ok
					//	s.Append(@"1.5cm ");
					s.Append(@"of q").Append(i - 1);
					s.Append(@"]");
				}
				s.Append(@" {$q_{").Append(i).AppendLine("}$};");
			}
			s.AppendLine();

			s.AppendLine(@"    \path");
			foreach (var transition in fsm.Transitions)
			{
				int index1 = transition.Item1; //states.IndexOf(transition.Item1);
				int index2 = transition.Item3; //states.IndexOf(transition.Item3);
				s.Append(@"    (q").Append(index1).Append(@") edge [");
				int diff = index2 - index1;
				if (diff == 0)
					s.Append(@"loop above");
				else if (diff > 1)
				{
					s.Append(String.Format("out={0},in={1}", 315 + diff * 10, 135 - diff * 10));
				}
				else if (diff < 0)
				{
					s.Append(String.Format("out={0},in={1}", 135 + 10 - (diff - 1) * 10, 315 - 10 + (diff - 1) * 10));
				}
				s.Append(@"] node [");
				s.Append(@"sloped,above");
				s.Append(@"] {$").Append(String.Join(",", transition.Item2)).Append(@"$} (q").Append(index2).AppendLine(@")");
			}

			s.AppendLine(@"    ;");
			s.AppendLine();
			s.AppendLine(@"  \end{tikzpicture}");
			s.AppendLine(@"  \caption{graphical representation of the solution}");
			s.Append(@"\end{figure}");

			return s.ToString();
		}

	}
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Phinite
{
	/// <summary>
	/// Used to generate LaTeX code used as a final output of the application.
	/// </summary>
	public static class LatexWriter
	{
		public static readonly string LatexOutputTextOpening
			= "\\documentclass{article}\n"
			+ "\n"
			+ "\\usepackage{fullpage}\n"
			//+ "\\usepackage{tabularx}\n"
			+ "\\usepackage{breqn}\n"
			//+ "\\usepackage{amsmath}\n"
			+ "\\usepackage[usenames,dvipsnames,svgnames]{xcolor}\n"
			+ "\\usepackage{tikz}\n"
			+ "\\usetikzlibrary{arrows,positioning,automata}\n"
			+ "\n"
			+ "\\begin{document}\n"
			+ "\n"
			+ "\\title{Finite-state machine constructed from a regual expression}\n"
			+ "\\author{Generated by $\\Phi$NITE}\n"
			+ "\\date{\\today}\n"
			+ "\\maketitle";

		public static readonly string LatexOutputTextClosing
			= @"\end{document}";

		public static string GenerateFullLatex(string originalInput,
			RegularExpression regexp, FiniteStateMachine fsm,
			bool includeOpening, bool includeEnding)
		{
			StringBuilder s = new StringBuilder();

			if (includeOpening)
			{
				s.AppendLine(LatexOutputTextOpening);
				s.AppendLine();
			}

			s.AppendLine(@"\section{Summary}");
			s.AppendLine("This document illustrates process of construction of a finite-state machine that"
				+ " is equivalent to a given regular expression.");
			s.AppendLine();

			s.AppendLine(@"\section{Input}");
			s.AppendLine("Input expression:");
			s.AppendLine(@"\begin{dmath*}");
			s.AppendLine(originalInput.Replace(RegularExpression.TagsStrings[InputSymbolTag.EmptyWord], @"\epsilon"));
			s.AppendLine(@"\end{dmath*}");
			s.AppendLine();

			s.AppendLine(@"\noindent Input expression with ambiguity safeguards:");
			s.AppendLine(@"\begin{dmath*}");
			s.AppendLine(regexp.ToString().Replace(RegularExpression.TagsStrings[InputSymbolTag.EmptyWord], @"\epsilon"));
			s.AppendLine(@"\end{dmath*}");
			s.AppendLine();

			//s.AppendLine(@"\section{Solution process}");
			//s.AppendLine(@"Not implemented.");
			//s.AppendLine();
			//\subsection{Labeling}
			//\subsection{Derivation}

			//s.AppendLine(@"\newpage");
			s.AppendLine();

			s.AppendLine(@"\section{Final result}");
			s.AppendLine(@"This section contains both textual and graphical representations of the solution.");
			s.AppendLine();

			s.AppendLine(@"\subsection{States}");
			s.AppendLine(@"");
			s.AppendLine();
			//\begin{tabularx}{\linewidth}{Xc}
			//  \hline
			//  Expression & State \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{0}$ \\
			//  \hline
			//  $a^*$ & $q_{20}$ \\
			//  \hline
			//\end{tabularx}

			s.AppendLine(@"\subsection{Transitions}");
			s.AppendLine(@"");
			s.AppendLine();
			//\begin{tabularx}{\linewidth}{XcccX}
			//  \hline
			//  Starting expression & From & Symbol & To & Resulting expression \\
			//  \hline
			//  $a^*$ & $q_{0}$ & a & $q_{0}$ & $a^*$ \\
			//  \hline
			//\end{tabularx}


			s.AppendLine(@"\subsection{Graph}");
			s.AppendLine(@"The figure below shows a deterministic finite-state machine that is equivalent to the given input.");
			s.AppendLine();

			s.AppendLine(FiniteStateMachineToLatex(fsm));
			s.AppendLine();

			if (includeEnding)
			{
				s.AppendLine(LatexOutputTextClosing);
				s.AppendLine();
			}

			return s.ToString();
		}

		public static string FiniteStateMachineToLatex(FiniteStateMachine fsm)
		{
			StringBuilder s = new StringBuilder();

			s.AppendLine(@"\begin{figure}[ht!]");
			s.AppendLine(@"  \centering");
			s.AppendLine(@"  \begin{tikzpicture}");
			//s.AppendLine(@"    [>=stealth',shorten >=1pt,node distance=2cm,on grid,initial/.style={}]");
			//s.AppendLine(@"    [->,>=stealth',shorten >=1pt,node distance=2cm,auto,transform shape]");
			s.AppendLine(@"    [->,>=stealth',shorten >=1pt,node distance=2.5cm,on grid,auto,transform shape]");
			s.AppendLine();

			//s.AppendLine(@"    \node[initial,state] (q0) {$q_0$};");
			var states = fsm.States;
			for (int i = 0; i < states.Count; ++i)
			{
				var state = fsm.States[i];
				s.Append(@"    \node[");
				if (i == 0)
					s.Append(@"initial,");
				s.Append(@"state");
				if (fsm.FinalStates.Contains(state))
					s.Append(@",accepting");
				s.Append(@"] (q").Append(i).Append(@")");
				if (i > 0)
				{
					s.Append(@" [below right = ");
					//if(false) // TODO: decrease distance between nodes if it is ok
					//	s.Append(@"1.5cm ");
					s.Append(@"of q").Append(i - 1);
					s.Append(@"]");
				}
				s.Append(@" {$q_{").Append(i).AppendLine("}$};");
			}
			s.AppendLine();

			s.AppendLine(@"    \path");
			foreach (var transition in fsm.Transitions)
			{
				int index1 = states.IndexOf(transition.Item1);
				int index2 = states.IndexOf(transition.Item3);
				s.Append(@"    (q").Append(index1).Append(@") edge [");
				int diff = index2 - index1;
				if (diff == 0)
					s.Append(@"loop above");
				else if (diff > 1)
				{
					s.Append(String.Format("out={0},in={1}", 315 + diff * 10, 135 - diff * 10));
				}
				else if (diff < 0)
				{
					s.Append(String.Format("out={0},in={1}", 135 + 10 - (diff - 1) * 10, 315 - 10 + (diff - 1) * 10));
				}
				s.Append(@"] node [");
				s.Append(@"sloped,above");
				s.Append(@"] {$").Append(transition.Item2).Append(@"$} (q").Append(index2).AppendLine(@")");
			}

			s.AppendLine(@"    ;");
			s.AppendLine();
			s.AppendLine(@"  \end{tikzpicture}");
			s.AppendLine(@"  \caption{graphical representation of the final answer}");
			s.Append(@"\end{figure}");

			return s.ToString();
		}

	}
}

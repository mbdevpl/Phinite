using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;

namespace Phinite
{
	/// <summary>
	/// Interaction logic for App.xaml
	/// </summary>
	public partial class App : Application
	{
		#region basic information

		public static readonly string Name = "ΦNITE";

		public static readonly string NameLatex = @"$\Phi$NITE";

		public static readonly Version Version = Assembly.GetExecutingAssembly().GetName().Version;

		public static readonly String VersionString = Version.ToString();

		#endregion

		#region regexp examples

		public static readonly String DefaultExample = "Infinite loop 2"; //"Yay!";

		/// <summary>
		/// Set of example regular expressions.
		/// </summary>
		public static readonly Dictionary<string, string> ExpressionExamples
			= new Dictionary<string, string>
			{
				{"Empty word", "."},
				{"Concatenation", "ababa"},
				{"Union", "aa+ab+ba+bb"},
				{"Empty word, concat. & union", "a(a+.)b(a+b)"},
				{"Kleene star", "ab^*"},
				{"Empty word, concat., union & star", "(a(a+.)(b(a+b))^*)^*"},
				{"Kleene plus", "a+b^+"},
				{"Parentheses", "(ab)^*+ab^*"},
				{"Binary numbers", "0+1(0+1)^*"},
				{"3 digit hexadecimal numbers", "(1+2+3+4+5+6+7)(0+1+2+3+4+5+6+7)(0+1+2+3+4+5+6+7)"},
				{"Example from old BA", "a^+c^+ + ab^+c"},
				{"Example from BA", "a(a+b)^*b"},
				{"Example from TA", "a^+b^+ + ab^+c"},
				{"High tree", "((((((((a^+b)^+c)^+d)^+e)^+f)^+g)^+i)^+j)^+k"},
				{"4 long paths", "aaaaaaae+bbbbbbe+ccccce+dddde"},
				{"Seemingly hard 1", "(a+ab+abc+abcd+abcde+abcdef)^*"},
				{"Seemingly hard 2", "(f+ef+def+cdef+bcdef+abcdef)^*"},
				{"Seemingly hard 3", "(a+.)^*b"},
				{"Seemingly hard 4", "(ab^*)^*"},
				{"Hard", "(((b)^*)((a((b)^*))^*))"},
				{"Pseudo e-mail", "(a+b+c+d+e+f+g+h+i+m+l+u+v+w+x+y+z)^+@(a+b+c+d+e+f+g+h+i+m+l+u+v+w+x+y+z)^+_(pl+eu+com+org+net)"},
				{"Yay!", "(A^+B^*C^+D^*E^+F^*G^+H^*I^+J^*K^+L^*M^+N^*O^+P^*R^+S^*T^+U^*V^+W^*X^+Y^*Z^+)^*"},
				{"Mess!", "(A^+B^*C^*D^*E^*F^*G^*H^*I^*J^*K^*L^*M^*N^*O^*P^*R^*S^+T^*U^*V^*W^*X^*Y^*Z^*)^*"},
				{"Infinite loop", "(a^*a)^*"},
				{"Infinite loop 2", "(a(a+.)b^*)^*"},
				{"Decimal numbers, obscured", "0+(1+2+3+4+5+6+7+8+9)((0+1+2+3+4+5+6+7+8+9)^*(0+1+2+3+4+5+6+7+8+9))^*"},
				{"Obscured", "(a+b)^*(ab+ba+.)"},
				{"All features", "(.+bb)(aabb)^+(.+aa)+(aa+bb)^*(aa+.)"}
			};

		public static readonly Dictionary<string, string> WordExamples
			= new Dictionary<string, string>
			{
				{"Empty word", ""},
				{"Concatenation", "abab"},
				{"Union", "ba"},
				{"Empty word, concat. & union", "aabb"},
				{"Kleene star", "abbb"},
				{"Empty word, concat., union & star", "aabbabb"},
				{"Kleene plus", "bbbb"},
				{"Parentheses", "ababab"},
				{"Binary numbers", "11001010"},
				{"3 digit hexadecimal numbers", "103"},
				{"Example from old BA", "abbbc"},
				{"Example from BA", "abbaab"},
				{"Example from TA", "aaabbb"},
				{"High tree", "abcdefgijk"},
				{"4 long paths", "bbbbbbe"},
				{"Seemingly hard 1", "abcdeabc"},
				{"Seemingly hard 2", "defbcdef"},
				{"Seemingly hard 3", "aaab"},
				{"Seemingly hard 4", "abbabbb"},
				{"Hard", "bbbabbab"},
				{"Pseudo e-mail", "mb@mbdev_pl"},
				{"Yay!", "ABCDEFGHIJKLMNOPRSTUVWXYZ"},
				{"Mess!", "ABCDEFGHIJKLMNOPRSTUVWXYZ"},
				{"Infinite loop", "aaaa"},
				{"Infinite loop 2", "aabbabb"},
				{"Decimal numbers, obscured", "5320481"},
				{"Obscured", "aaaaa"},
				{"All features", "bbaabbaabbaabbaa"}
			};

		#endregion

		#region latex templates

		public static string Template_UserGuide
		{ get { if (template_UserGuide == null) template_UserGuide = Init_UserGuide(); return template_UserGuide; } }
		private static string template_UserGuide;

		private static string Init_UserGuide()
		{
			var s = new StringBuilder();

			s.Append(@"\documentclass{article}

\usepackage{fullpage}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{url}
			
\begin{document}

\title{Phinite user guide}
\author{Generated by $\Phi$NITE}
\date{\today}
\maketitle

%\tableofcontents

%\newpage

\section{Introduction}

\subsection{About Phinite}
[data:about]

\subsection{Requirements}

\subsubsection{Minimum requirements}
\begin{itemize}
\item Windows 7 operating system
\item .NET 4.0 framework, full profile
\end{itemize}

\subsubsection{Recommended}
\begin{itemize}
\item modern multi-core processor
\item at least 1 GB of free memory
\end{itemize}

\subsubsection{Requirements for PDF report feature}
\begin{itemize}
\item any PDF viewer
\item any LaTeX distibution with required packages, i.e.
\begin{itemize}[noitemsep,nolistsep]
\item l3kernel
\item preprint
\item pgf
\item hm
\item hs
\item xcolor
\end{itemize}
\end{itemize}

\section{Main features of application}
Information from this section is accessible via buttons with a question mark (\verb""?"")
that are scattered across Phinite.

\subsection{Regular expression input}
[data:regexpinput]

\subsection{Parse tree view}
[data:parsetree]

\subsection{Finite-state machine construction}
[data:construction]

\subsection{User-assisted machine construction}
[data:userhelp]

\subsection{PDF report generation}
[data:report]

\subsection{Word input}
[data:wordinput]

\subsection{Word evaluation}
[data:evaluation]

\subsection{Settings screen}
[data:settings]

\end{document}
");

			return s.ToString();
		}

		public static string Template_Report
		{ get { if (template_Report == null) template_Report = Init_Report(); return template_Report; } }
		private static string template_Report;

		private static string Init_Report()
		{
			return @"\documentclass{article}

\usepackage{fullpage}
\usepackage{tabularx}
\usepackage{breqn}
%\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,automata}
\usepackage{textcomp}

\begin{document}

\title{Finite-state machine constructed from a regular expression}
\author{Generated by $\Phi$NITE}
\date{\today}
\maketitle

\section{Summary}
This document illustrates process of construction of a finite-state machine that
is equivalent to a given regular expression.
This document and its \LaTeX{} source code are \textcopyleft{} copyleft - you are free
to use them in any way.

\section{Input}
Input expression:
\begin{dmath*}
[data:inputoriginal]
\end{dmath*}

\noindent
Input expression after optimizations and with ambiguity safeguards:
\begin{dmath*}
[data:inputoptimized]
\end{dmath*}

\noindent
Further calculations are based on the preprocessed (i.e. second) expression.

\section{Final result}
This section contains both textual and graphical representations of the solution.

\subsection{States}
The table lists all distincts states that were identified, together with labels that were assigned to them.

\vspace{10pt}
\noindent
\begin{tabularx}{\linewidth}{clX}
\hline
State & Remarks & Expression \\
[data:tablestates]
\hline
\end{tabularx}

\subsection{Transitions}
The table lists all transitions that do not lead to rejecting state.

\vspace{10pt}
\noindent
\begin{tabularx}{\linewidth}{cccXX}
\hline
From & Symbol & To & Starting expression & Resulting expression \\
[data:tabletransitions]
\hline
\end{tabularx}

\subsection{Graph}
The figure below shows a deterministic finite-state machine that is equivalent to the given input.
For simplification, the rejecting state is not drawn. If for any state for any letter of the alphabet,
there is an edge missing, it means that such transition leads to rejecting state.

\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}
[data:graph]
  \end{tikzpicture}
  \caption{graphical representation of the solution}
\end{figure}

\end{document}
";
		}

		public static string Template_ReportState
		{ get { if (template_ReportState == null) template_ReportState = Init_ReportState(); return template_ReportState; } }
		private static string template_ReportState;

		private static string Init_ReportState()
		{
			return @"\hline
$q_{[data:label]}$ & [data:remarks] & $[data:regexp]$ \\";
		}

		public static string Template_ReportTransition
		{ get { if (template_ReportTransition == null) template_ReportTransition = Init_ReportTransition(); return template_ReportTransition; } }
		private static string template_ReportTransition;

		private static string Init_ReportTransition()
		{
			return @"\hline
$q_{[data:label1]}$ & $[data:letters]$ & $q_{[data:label2]}$ & $[data:regexp1]$ & $[data:regexp2]$ \\";
		}

		public static string Template_ReportGraphState
		{ get { if (template_ReportGraphState == null) template_ReportGraphState = Init_ReportGraphState(); return template_ReportGraphState; } }
		private static string template_ReportGraphState;

		private static string Init_ReportGraphState()
		{
			return @"    \node[[data:flags]] (q[data:label]) at ([data:x],[data:y]) {$q_{[data:label]}$};";
		}

		public static string Template_ReportGraphTransition
		{ get { if (template_ReportGraphTransition == null) template_ReportGraphTransition = Init_ReportGraphTransition(); return template_ReportGraphTransition; } }
		private static string template_ReportGraphTransition;

		private static string Init_ReportGraphTransition()
		{
			return @"    (q[data:label1]) edge [out=[data:angle1],in=[data:angle2][data:flags]] node [sloped[data:lettersflags]] {$[data:letters]$} (q[data:label2])";
		}

		#endregion

		#region information messages

		public static string Text_About
		{ get { if (text_About == null) text_About = Init_About(false); return text_About; } }
		private static string text_About;

		public static string Latex_About
		{ get { if (latex_About == null) latex_About = Init_About(true); return latex_About; } }
		private static string latex_About;

		private static string Init_About(bool latex)
		{
			StringBuilder s = new StringBuilder();

			s.Append(" Version ").Append(App.VersionString).AppendLine();
			s.AppendLine();

			if (latex) s.AppendLine(@"\begin{verbatim}");
			s.AppendLine(@"Phinite: finite-state machine builder and simulator
Copyright (C) 2013  Mateusz Bysiek, http://mbdev.pl/
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.");
			if (latex) s.AppendLine(@"\end{verbatim}");
			s.AppendLine();

			s.Append(latex ? App.NameLatex : App.Name).AppendLine(" uses:");
			if (latex) s.AppendLine(@"\begin{itemize}");
			s.Append(latex ? @"\item" : "-")
				.Append(" Extended WPF Toolkit, ")
					.Append(latex ? @"\url{" : "").Append("https://wpftoolkit.codeplex.com/").Append(latex ? @"}" : "")
					.AppendLine(", Microsoft Public License")
				.Append(latex ? @"\item" : "-")
				.Append(" WPF Converters, ")
					.Append(latex ? @"\url{" : "").Append("https://wpfconverters.codeplex.com/").Append(latex ? @"}" : "")
					.AppendLine(", Microsoft Public License")
				.Append(latex ? @"\item" : "-")
				.Append(" QuickGraph, ")
					.Append(latex ? @"\url{" : "").Append("https://quickgraph.codeplex.com/").Append(latex ? @"}" : "")
					.AppendLine(", Apache License 2.0")
				.Append(latex ? @"\item" : "-")
				.Append(" Graph" + (latex ? @"\" : "") + "#, ")
					.Append(latex ? @"\url{" : "").Append("https://graphsharp.codeplex.com/").Append(latex ? @"}" : "")
					.AppendLine(", Microsoft Public License")
				.Append(latex ? @"\item" : "-")
				.Append(" Arrowheads, ")
					.Append(latex ? @"\url{" : "").Append("http://charlespetzold.com/blog/2007/04/191200.html").Append(latex ? @"}" : "")
					.AppendLine(", royalty-free license");
			if (latex) s.AppendLine(@"\end{itemize}");
			s.AppendLine();

			return s.ToString();
		}

		public static string Text_RegexpInput
		{ get { if (text_RegexpInput == null) text_RegexpInput = Init_RegexpInput(false); return text_RegexpInput; } }
		private static string text_RegexpInput;

		public static string Latex_RegexpInput
		{ get { if (latex_RegexpInput == null) latex_RegexpInput = Init_RegexpInput(true); return latex_RegexpInput; } }
		private static string latex_RegexpInput;

		private static string Init_RegexpInput(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("In a text box, enter a regular expression that is valid. You can use any symbol,");
			s.AppendLine("but remember that spaces will be ignored and some symbols have special meaning:");

			if (latex) s.AppendLine(@"\begin{itemize}[noitemsep,nolistsep]");
			foreach (var pair in RegularExpression.ReservedSymbols)
			{
				if (latex) s.Append(@"\item ").Append(@"\verb");
				s.Append('"').Append(pair.Key).Append('"');
				s.Append(" - ").AppendLine(Regex.Replace(pair.Value.ToString(), "([a-z])([A-Z])", "$1 $2").ToLower());
			}
			if (latex) s.AppendLine(@"\end{itemize}");
			s.AppendLine();

			s.AppendLine("If you abide by the following rules, your expression will surely be valid:");
			int i = 0;
			if (latex) s.AppendLine(@"\begin{enumerate}");
			foreach (var rule in RegularExpression.Rules)
				s.Append(latex ? @"\item " : String.Format("  {0}.  ", ++i)).AppendLine(rule);
			if (latex) s.AppendLine(@"\end{enumerate}");
			s.AppendLine();

			s.AppendLine("If in doubt, load one of the example expressions using leftmost menu option to see how it works.");

			return s.ToString();
		}

		public static string Text_ParseTree
		{ get { if (text_ParseTree == null) text_ParseTree = Init_ParseTree(false); return text_ParseTree; } }
		private static string text_ParseTree;

		public static string Latex_ParseTree
		{ get { if (latex_ParseTree == null) latex_ParseTree = Init_ParseTree(true); return latex_ParseTree; } }
		private static string latex_ParseTree;

		private static string Init_ParseTree(bool latex)
		{
			var s = new StringBuilder();

			s.Append("This screen presents a parse tree and two versions of the input regular expression above it.");
			s.Append(" If you check that the second, (\"").Append("Validated and optimized input")
				.Append("\"), has the same meaning as you intended, you may safely continue.").AppendLine();
			s.AppendLine();

			s.Append("If not, please cancel the computation and enter the expression in such way that it is properly understood by the program.");
			s.Append(" Please remember to follow the rules of regular expression operators precedence, use special symbols properly, etc.");

			return s.ToString();
		}

		public static string Text_Construction
		{ get { if (text_Construction == null) text_Construction = Init_Construction(false); return text_Construction; } }
		private static string text_Construction;

		public static string Latex_Construction
		{ get { if (latex_Construction == null) latex_Construction = Init_Construction(true); return latex_Construction; } }
		private static string latex_Construction;

		private static string Init_Construction(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("Use buttons in the left-bottom corner to control the construction process.");
			s.AppendLine();

			s.AppendLine("You can doubleclick regular expressions in both tables to see their parse trees.");
			s.AppendLine();

			s.Append("When the construction is complete, you may go right to word evaluation screen,");
			s.AppendLine(" or before that stop for a moment to view a PDF with construction results report.");
			s.AppendLine();

			s.Append("To do the former, select \"Go to word evaluation\", and to do the latter select \"Generate LaTeX code\".");

			return s.ToString();
		}

		public static string Text_Report
		{ get { if (text_Report == null) text_Report = Init_Report(false); return text_Report; } }
		private static string text_Report;

		public static string Latex_Report
		{ get { if (latex_Report == null) latex_Report = Init_Report(true); return latex_Report; } }
		private static string latex_Report;

		private static string Init_Report(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("You may edit/copy the contents of this screen to, for example, use it as a part of some other LaTeX document,");
			s.AppendLine("because this content is copyleft (no rights reserved).");
			s.AppendLine();

			s.AppendLine("You can generate new report after editing the latex source code - the new generated PDF file will reflect");
			s.AppendLine("changes made by you.");
			s.AppendLine();

			s.AppendLine("All .tex and .pdf files are saved in the directory where the Phinite application resides.");
			s.AppendLine();

			return s.ToString();
		}

		public static string Text_WordInput
		{ get { if (text_WordInput == null) text_WordInput = Init_WordInput(false); return text_WordInput; } }
		private static string text_WordInput;

		public static string Latex_WordInput
		{ get { if (latex_WordInput == null) latex_WordInput = Init_WordInput(true); return latex_WordInput; } }
		private static string latex_WordInput;

		private static string Init_WordInput(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("Enter some word. You can use any symbols,");
			s.AppendLine("but remember that spaces will be ignored and some symbols are forbidden:");

			if (latex) s.AppendLine(@"\begin{itemize}[noitemsep,nolistsep]");
			foreach (var symbol in RegularExpression.ForbiddenSymbols)
			{
				if (latex) s.Append(@"\item \verb");
				s.Append("\"").Append(symbol).AppendLine("\"");
			}
			if (latex) s.AppendLine(@"\end{itemize}");
			s.AppendLine();

			s.Append("Leave the field blank to evaluate (i.e. check if the machine accepts) the empty word.");
			s.AppendLine();

			s.AppendLine("If you are unsure, just start computing without any input");
			s.Append("or write just a single letter to see how the basic case works.");

			return s.ToString();
		}

		public static string Text_Evaluation
		{ get { if (text_Evaluation == null) text_Evaluation = Init_Evaluation(false); return text_Evaluation; } }
		private static string text_Evaluation;

		public static string Latex_Evaluation
		{ get { if (latex_Evaluation == null) latex_Evaluation = Init_Evaluation(true); return latex_Evaluation; } }
		private static string latex_Evaluation;

		private static string Init_Evaluation(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("Like in construction phase, use controls in the bottom-left corner of the screen");
			s.AppendLine(" to control evaluation process.");
			s.AppendLine();

			s.AppendLine("When the evaluation is finished, orange background indicates that the word was rejected.");
			s.AppendLine(" On the other hand, green background indicates that the word was accepted by the finite-state machine.");
			s.AppendLine();

			s.AppendLine("Use buttons on the right to either return to regular expression input screen,");
			s.AppendLine(" or to return to word input screen.");
			s.AppendLine();

			return s.ToString();
		}

		public static string Text_UserHelp
		{ get { if (text_UserHelp == null) text_UserHelp = Init_UserHelp(false); return text_UserHelp; } }
		private static string text_UserHelp;

		public static string Latex_UserHelp
		{ get { if (latex_UserHelp == null) latex_UserHelp = Init_UserHelp(true); return latex_UserHelp; } }
		private static string latex_UserHelp;

		private static string Init_UserHelp(bool latex)
		{
			var s = new StringBuilder();

			s.AppendLine("Buttons on this screen have the following meaning:");

			if (latex) s.AppendLine(@"\begin{itemize}");
			if (latex) s.Append(@"\item ");
			s.AppendLine("Equivalent - given expression is equivalent to the one selected in the table.");
			if (latex) s.Append(@"\item ");
			s.AppendLine("Different - the expression is different from all labeled expressions.");
			if (latex) s.Append(@"\item ");
			s.AppendLine("No idea - PHINITE will automatically solve this problem.");
			if (latex) s.AppendLine(@"\end{itemize}");
			s.AppendLine();

			s.AppendLine(@"Hint: closing the window is the same as last option.

You can doubleclick regular expressions in the table to see their parse trees.
This might make the comparison of long expressions easier.

Also, you can doubleclick the similarity percentage to see details of why Phinite
estimated the similarity in such way.
");

			return s.ToString();
		}

		#endregion

		static App()
		{
		}

	}
}
